"""
Room_compare/ room_inspection tool(s).
Loosely,
  "Room compare":     refers to the tabular view of a the rooms in a building at a given time
  "Room inspector":   refers to the 24 hour plot(s) generated by clicking on a specific room.
"""

from datetime import datetime, timedelta
import pandas as pd
from bokeh.embed import components
from bokeh.plotting import figure
from bokeh.layouts import column
from pandas.core.base import DataError

from analysis.anomaly_detection.anomaly_detection import pivot_df, return_anomalous_points
from marthas_dashboard.api import API

api = API()
TIME_FMT = "%Y-%m-%d %H:%M:%S"


def get_room_comparison_results(keywords):
    """Use arguments to build df for displaying"""

    # Process arguments
    building_id, date, timestamp = keywords["building"], keywords["date"], keywords["timestamp"]
    full_timestamp = date + " " + timestamp

    # Make api calls
    rooms = api.building_rooms(building_id)
    points = api.building_points(building_id)
    vals = api.building_values_at_time(building_id, full_timestamp)

    # Check if queries are empty DataFrames are incorrect types
    query_frames = [rooms, points, vals]
    if any((len(x) == 0) or (not isinstance(x, (pd.DataFrame, pd.Series))) for x in query_frames):
        return pd.DataFrame()

    # Merge dfs together
    _df = pd.merge(points, rooms, left_on='roomid', right_on='id', suffixes=('_point', '_room'))
    df = pd.merge(_df, vals, left_on='id_point', right_on='pointid', suffixes=('_point', '_val'))

    # If merge results in empty df, return empty df now
    if len(df) == 0:
        return pd.DataFrame()

    # attempt to tag points, pivot so tags become columns
    # This is to be replaced with Zephyr's mighty tagging system, eventually!
    df = hacky_tagging(df)
    df = pivot_table_around_tags(df)
    return df


def get_room_inspector_results(searches):
    """Activated after clicking a cell in room_compare table.
    Returns df ready for plotting (datetime and tags are columns)"""

    # From url args (searches), get "ts" (date + timestamp), building_id, room_name
    ts = datetime.strptime(' '.join([searches['date'], searches['timestamp']]), TIME_FMT)
    building_id = searches['building']
    room_name = searches['room']

    # Compute "start" (12 hours earlier) and "stop" (12 hours later) than timestamp
    start = (ts - timedelta(hours=12)).strftime(TIME_FMT)
    end = (ts + timedelta(hours=12)).strftime(TIME_FMT)

    # Make api calls (these should be cached from room_compare)
    points = api.building_points(building_id)
    rooms = api.building_rooms(building_id)
    vals = api.building_values_in_range(building_id, start, end)

    # Filter out all but selected room
    rooms = rooms.query('name == "{}"'.format(room_name))

    # Merge dfs together
    _df = pd.merge(points, rooms, left_on='roomid', right_on='id', suffixes=('_point', '_room'))
    df = pd.merge(_df, vals, left_on='id_point', right_on='pointid', suffixes=('_point', '_val'))

    # Attempt to tag
    df = hacky_tagging(df)

    # Add datetime column
    df['datetime'] = pd.to_datetime(df.date + ' ' + df.time)

    # Ignore points tagged as 'none'
    df = df.query('tag != "none"')

    # Remove points with 'none' tag,
    # Pivot so tags b/c columns, datetime is index
    return (df.query('tag != "none"')
            .pivot(index='datetime', columns='tag', values='pointvalue')
            .reset_index().rename_axis(None, axis=1))


def make_all_room_inspector_graphs(df):
    """Creates Bokeh plots for room inspector, once table cell clicked"""

    # tags is list of column names, excluding datetime
    tags = list(df.set_index('datetime').columns)

    # Make a plot for each tag
    plots = [make_room_inspector_graph(df, tag) for tag in tags]

    # Put plots in a "column" layout
    return components(column(plots))


def make_room_inspector_graph(df, tag):
    """Creates Bokeh plots for room inspector, once table cell clicked"""
    p = figure(plot_width=300, plot_height=300, x_axis_type='datetime')
    p.line(df['datetime'], df[tag], line_width=2)
    p.xaxis.axis_label = "time"
    p.yaxis.axis_label = tag
    p.toolbar.logo = None
    return p


def hacky_tagging(df):
    """Attempt to tag points in DF; To be replaced with DB tagging system."""

    df['tag'] = 'none'  # add tag column (set to 'none' by default)

    df_rtemp = df.query('name == "ROOMTEMP"')  # tag 'room_temp'
    df.loc[df_rtemp.index, 'tag'] = 'room_temp'

    df_rvalve = df.query('name == "R VALVE"')  # tag 'valve'
    df.loc[df_rvalve.index, 'tag'] = 'valve'

    return df


def pivot_table_around_tags(df):
    """Pivot table so tags become columns"""

    # Get values where tag is not 'none'
    df = df.query('tag != "none"')

    # Call pivot_on_tag with each tag
    tags = list(df.tag.unique())
    frames = [_pivot_on_tag(df, t) for t in tags]
    final_df = pd.concat(frames, axis=1)
    final_df.index.name = frames[0].index.name
    return final_df.reset_index()


def _pivot_on_tag(df, tag):
    """Helper function to 'pivot_table_around_tags'
    :param df: tagged df (with all rooms, points, and vals for given building/timestamp)
    :param tag: tag to extact (eg, "valve")
    :return: filtered/pivoted df: <index = name_room, columns = [pointid_{tag}, {tag}]>
    """
    try:
        df = (df.query('tag == "{}"'.format(tag))
              .pivot_table(index=['name_room', 'pointid'], columns='tag', values='pointvalue')
              .reset_index().rename_axis(None, axis=1)
              .rename({'pointid': 'pointid_{}'.format(tag)}, axis='columns'))
    except DataError:
        df = pd.DataFrame(columns=['name_room', tag])  # make empty DF

    return df.set_index('name_room')


def get_anomalous_points(search_results, searches):
    start_date = searches["date"] + " 00:00:00"
    end_date = searches["date"] + " 23:45:00"
    df = api.building_values_in_range(searches["building"], start_date, end_date)

    valve_data = df[df['pointid'].isin(search_results['pointid_valve'])]
    room_temp_data = df[df['pointid'].isin(search_results['pointid_room_temp'])]
    data_frames = [valve_data, room_temp_data]

    anomalous_pts = []
    for frame in data_frames:
        pivoted_df = pivot_df(frame)
        size_threshold = pivoted_df.shape[0] * 0.03
        anomalous_pts.extend(
            return_anomalous_points(
                pivoted_df, n_clusters=4, n_init=10,
                std_threshold=3, size_threshold=size_threshold))

    # Convert from point names to point ids
    pt_ids = []
    for pt_name in anomalous_pts:
        pt_ids.append(
            df[df['pointname'] == pt_name].iloc[0]['pointid'])

    # Add column to search results with anomaly info
    search_results['room_temp_anomalous'] = search_results['pointid_room_temp'].isin(pt_ids)
    search_results['valve_anomalous'] = search_results['pointid_valve'].isin(pt_ids)
    return search_results


def generate_15_min_timestamps():
    timestamps = []
    first_time = datetime.strptime("00:00:00", "%H:%M:%S")
    end_time = datetime.strptime("23:59:59", "%H:%M:%S")
    while first_time < end_time:
        timestamps.append(first_time.strftime("%H:%M:%S"))
        first_time += timedelta(minutes=15)
    return timestamps
